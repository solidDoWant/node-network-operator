package graphsearch

import (
	"fmt"

	"github.com/dominikbraun/graph"
)

// BFSWithEdge performs a breadth-first search on the graph g starting from the vertex start.
// The visit function is called for each visited vertex, with the vertex and the edge used to
// reach that vertex. If visit returns true, the search is stopped.
// An error is returned if the start vertex is not found in the graph, if the adjacency map
// cannot be retrieved, or if the visit function returns an error.
// This implementation uses a queue and is non-recursive. The queue is allocated for the worst-case.
// If the visited function returns an error, the search is stopped and the error is returned.
func BFSWithEdge[K comparable, T any](g graph.Graph[K, T], start K, visit func(K, *graph.Edge[K]) error) error {
	adjacencyMap, err := g.AdjacencyMap()
	if err != nil {
		return fmt.Errorf("could not get adjacency map: %w", err)
	}

	if _, ok := adjacencyMap[start]; !ok {
		return fmt.Errorf("could not find start vertex with hash %v", start)
	}

	// Allocate for worst case where all vertices are in the queue at once.
	// Graphs generated by this program will be small, so this should not be a problem.
	type queueData struct {
		vertex K
		edge   *graph.Edge[K]
	}

	queue := make([]queueData, 0, len(adjacencyMap))
	visited := make(map[K]bool, len(adjacencyMap))

	visited[start] = true
	queue = append(queue, queueData{vertex: start})

	for len(queue) > 0 {
		currentHash := queue[0]
		queue = queue[1:]

		// Stop traversing the graph if the visit function returns true.
		if err := visit(currentHash.vertex, currentHash.edge); err != nil {
			return fmt.Errorf("visit function returned an error: %w", err)
		}

		for adjacentVertex, adjacentEdge := range adjacencyMap[currentHash.vertex] {
			if _, ok := visited[adjacentVertex]; !ok {
				visited[adjacentVertex] = true
				queue = append(queue, queueData{vertex: adjacentVertex, edge: &adjacentEdge})
			}
		}
	}

	return nil
}
